{
  "version": 3,
  "sources": ["../../src/bcs-type.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58.js';\nimport { toB64 } from './b64.js';\nimport { toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n"],
  "mappings": "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",
  "names": ["options"]
}
