{"version":3,"file":"graphql.web.mjs","sources":["../src/kind.js","../src/error.ts","../src/parser.ts","../src/visitor.ts","../src/printer.ts","../src/values.ts"],"sourcesContent":["export const Kind = {\n  NAME: 'Name',\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  DIRECTIVE: 'Directive',\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n\n  /*\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension',\n  */\n};\n\nexport const OperationTypeNode = {\n  QUERY: 'query',\n  MUTATION: 'mutation',\n  SUBSCRIPTION: 'subscription',\n};\n","import { Maybe, Extensions, Source } from './types';\nimport { ASTNode } from './ast';\n\nexport class GraphQLError extends Error {\n  readonly locations: ReadonlyArray<any> | undefined;\n  readonly path: ReadonlyArray<string | number> | undefined;\n  readonly nodes: ReadonlyArray<any> | undefined;\n  readonly source: Source | undefined;\n  readonly positions: ReadonlyArray<number> | undefined;\n  readonly originalError: Error | undefined;\n  readonly extensions: Extensions;\n\n  constructor(\n    message: string,\n    nodes?: ReadonlyArray<ASTNode> | ASTNode | null,\n    source?: Maybe<Source>,\n    positions?: Maybe<ReadonlyArray<number>>,\n    path?: Maybe<ReadonlyArray<string | number>>,\n    originalError?: Maybe<Error>,\n    extensions?: Maybe<Extensions>\n  ) {\n    super(message);\n\n    this.name = 'GraphQLError';\n    this.message = message;\n\n    if (path) this.path = path;\n    if (nodes) this.nodes = (Array.isArray(nodes) ? nodes : [nodes]) as ASTNode[];\n    if (source) this.source = source;\n    if (positions) this.positions = positions;\n    if (originalError) this.originalError = originalError;\n\n    let _extensions = extensions;\n    if (!_extensions && originalError) {\n      const originalExtensions = (originalError as any).extensions;\n      if (originalExtensions && typeof originalExtensions === 'object') {\n        _extensions = originalExtensions;\n      }\n    }\n\n    this.extensions = _extensions || {};\n  }\n\n  toJSON(): any {\n    return { ...this, message: this.message };\n  }\n\n  toString() {\n    return this.message;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n}\n","/**\n * This is a spec-compliant implementation of a GraphQL query language parser,\n * up-to-date with the October 2021 Edition. Unlike the reference implementation\n * in graphql.js it will only parse the query language, but not the schema\n * language.\n */\nimport { Kind, OperationTypeNode } from './kind';\nimport { GraphQLError } from './error';\nimport { Source } from './types';\nimport type * as ast from './ast';\n\nlet input: string;\nlet idx: number;\n\nfunction error(kind: string) {\n  return new GraphQLError(`Syntax Error: Unexpected token at ${idx} in ${kind}`);\n}\n\nfunction advance(pattern: RegExp) {\n  pattern.lastIndex = idx;\n  if (pattern.test(input)) {\n    const match = input.slice(idx, (idx = pattern.lastIndex));\n    return match;\n  }\n}\n\nconst leadingRe = / +(?=[^\\s])/y;\nfunction blockString(string: string) {\n  const lines = string.split('\\n');\n  let out = '';\n  let commonIndent = 0;\n  let firstNonEmptyLine = 0;\n  let lastNonEmptyLine = lines.length - 1;\n  for (let i = 0; i < lines.length; i++) {\n    leadingRe.lastIndex = 0;\n    if (leadingRe.test(lines[i])) {\n      if (i && (!commonIndent || leadingRe.lastIndex < commonIndent))\n        commonIndent = leadingRe.lastIndex;\n      firstNonEmptyLine = firstNonEmptyLine || i;\n      lastNonEmptyLine = i;\n    }\n  }\n  for (let i = firstNonEmptyLine; i <= lastNonEmptyLine; i++) {\n    if (i !== firstNonEmptyLine) out += '\\n';\n    out += lines[i].slice(commonIndent).replace(/\\\\\"\"\"/g, '\"\"\"');\n  }\n  return out;\n}\n\n// Note: This is equivalent to: /(?:[\\s,]*|#[^\\n\\r]*)*/y\nfunction ignored() {\n  for (\n    let char = input.charCodeAt(idx++) | 0;\n    char === 9 /*'\\t'*/ ||\n    char === 10 /*'\\n'*/ ||\n    char === 13 /*'\\r'*/ ||\n    char === 32 /*' '*/ ||\n    char === 35 /*'#'*/ ||\n    char === 44 /*','*/ ||\n    char === 65279 /*'\\ufeff'*/;\n    char = input.charCodeAt(idx++) | 0\n  ) {\n    if (char === 35 /*'#'*/) while ((char = input.charCodeAt(idx++)) !== 10 && char !== 13);\n  }\n  idx--;\n}\n\nconst nameRe = /[_A-Za-z]\\w*/y;\nfunction name(): ast.NameNode | undefined {\n  let match: string | undefined;\n  if ((match = advance(nameRe))) {\n    return {\n      kind: 'Name' as Kind.NAME,\n      value: match,\n    };\n  }\n}\n\n// NOTE(Safari10 Quirk): This needs to be wrapped in a non-capturing group\nconst constRe = /(?:null|true|false)/y;\n\nconst variableRe = /\\$[_A-Za-z]\\w*/y;\nconst intRe = /-?\\d+/y;\n\n// NOTE(Safari10 Quirk): This cannot be further simplified\nconst floatPartRe = /(?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+/y;\n\nconst complexStringRe = /\\\\/g;\nconst blockStringRe = /\"\"\"(?:\"\"\"|(?:[\\s\\S]*?[^\\\\])\"\"\")/y;\nconst stringRe = /\"(?:\"|[^\\r\\n]*?[^\\\\]\")/y;\n\nfunction value(constant: true): ast.ConstValueNode;\nfunction value(constant: boolean): ast.ValueNode;\n\nfunction value(constant: boolean): ast.ValueNode | undefined {\n  let out: ast.ValueNode | undefined;\n  let match: string | undefined;\n  if ((match = advance(constRe))) {\n    out =\n      match === 'null'\n        ? {\n            kind: 'NullValue' as Kind.NULL,\n          }\n        : {\n            kind: 'BooleanValue' as Kind.BOOLEAN,\n            value: match === 'true',\n          };\n  } else if (!constant && (match = advance(variableRe))) {\n    out = {\n      kind: 'Variable' as Kind.VARIABLE,\n      name: {\n        kind: 'Name' as Kind.NAME,\n        value: match.slice(1),\n      },\n    };\n  } else if ((match = advance(intRe))) {\n    const intPart = match;\n    if ((match = advance(floatPartRe))) {\n      out = {\n        kind: 'FloatValue' as Kind.FLOAT,\n        value: intPart + match,\n      };\n    } else {\n      out = {\n        kind: 'IntValue' as Kind.INT,\n        value: intPart,\n      };\n    }\n  } else if ((match = advance(nameRe))) {\n    out = {\n      kind: 'EnumValue' as Kind.ENUM,\n      value: match,\n    };\n  } else if ((match = advance(blockStringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: blockString(match.slice(3, -3)),\n      block: true,\n    };\n  } else if ((match = advance(stringRe))) {\n    out = {\n      kind: 'StringValue' as Kind.STRING,\n      value: complexStringRe.test(match) ? (JSON.parse(match) as string) : match.slice(1, -1),\n      block: false,\n    };\n  } else if ((out = list(constant) || object(constant))) {\n    return out;\n  }\n\n  ignored();\n  return out;\n}\n\nfunction list(constant: boolean): ast.ListValueNode | undefined {\n  let match: ast.ValueNode | undefined;\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const values: ast.ValueNode[] = [];\n    while ((match = value(constant))) values.push(match);\n    if (input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListValue');\n    ignored();\n    return {\n      kind: 'ListValue' as Kind.LIST,\n      values,\n    };\n  }\n}\n\nfunction object(constant: boolean): ast.ObjectValueNode | undefined {\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const fields: ast.ObjectFieldNode[] = [];\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('ObjectField' as Kind.OBJECT_FIELD);\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('ObjectField');\n      fields.push({\n        kind: 'ObjectField' as Kind.OBJECT_FIELD,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('ObjectValue');\n    ignored();\n    return {\n      kind: 'ObjectValue' as Kind.OBJECT,\n      fields,\n    };\n  }\n}\n\nfunction arguments_(constant: boolean): ast.ArgumentNode[] {\n  const args: ast.ArgumentNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    let _name: ast.NameNode | undefined;\n    while ((_name = name())) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('Argument');\n      ignored();\n      const _value = value(constant);\n      if (!_value) throw error('Argument');\n      args.push({\n        kind: 'Argument' as Kind.ARGUMENT,\n        name: _name,\n        value: _value,\n      });\n    }\n    if (!args.length || input.charCodeAt(idx++) !== 41 /*')'*/) throw error('Argument');\n    ignored();\n  }\n  return args;\n}\n\nfunction directives(constant: true): ast.ConstDirectiveNode[];\nfunction directives(constant: boolean): ast.DirectiveNode[];\n\nfunction directives(constant: boolean): ast.DirectiveNode[] {\n  const directives: ast.DirectiveNode[] = [];\n  ignored();\n  while (input.charCodeAt(idx) === 64 /*'@'*/) {\n    idx++;\n    const _name = name();\n    if (!_name) throw error('Directive');\n    ignored();\n    directives.push({\n      kind: 'Directive' as Kind.DIRECTIVE,\n      name: _name,\n      arguments: arguments_(constant),\n    });\n  }\n  return directives;\n}\n\nfunction field(): ast.FieldNode | undefined {\n  let _name = name();\n  if (_name) {\n    ignored();\n    let _alias: ast.NameNode | undefined;\n    if (input.charCodeAt(idx) === 58 /*':'*/) {\n      idx++;\n      ignored();\n      _alias = _name;\n      _name = name();\n      if (!_name) throw error('Field');\n      ignored();\n    }\n    return {\n      kind: 'Field' as Kind.FIELD,\n      alias: _alias,\n      name: _name,\n      arguments: arguments_(false),\n      directives: directives(false),\n      selectionSet: selectionSet(),\n    };\n  }\n}\n\nfunction type(): ast.TypeNode {\n  let match: ast.NameNode | ast.TypeNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 91 /*'['*/) {\n    idx++;\n    ignored();\n    const _type = type();\n    if (!_type || input.charCodeAt(idx++) !== 93 /*']'*/) throw error('ListType');\n    match = {\n      kind: 'ListType' as Kind.LIST_TYPE,\n      type: _type,\n    };\n  } else if ((match = name())) {\n    match = {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: match,\n    };\n  } else {\n    throw error('NamedType');\n  }\n\n  ignored();\n  if (input.charCodeAt(idx) === 33 /*'!'*/) {\n    idx++;\n    ignored();\n    return {\n      kind: 'NonNullType' as Kind.NON_NULL_TYPE,\n      type: match,\n    };\n  } else {\n    return match;\n  }\n}\n\nconst typeConditionRe = /on/y;\nfunction typeCondition(): ast.NamedTypeNode | undefined {\n  if (advance(typeConditionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('NamedType');\n    ignored();\n    return {\n      kind: 'NamedType' as Kind.NAMED_TYPE,\n      name: _name,\n    };\n  }\n}\n\nconst fragmentSpreadRe = /\\.\\.\\./y;\n\nfunction fragmentSpread(): ast.FragmentSpreadNode | ast.InlineFragmentNode | undefined {\n  if (advance(fragmentSpreadRe)) {\n    ignored();\n    const _idx = idx;\n    let _name: ast.NameNode | undefined;\n    if ((_name = name()) && _name.value !== 'on') {\n      return {\n        kind: 'FragmentSpread' as Kind.FRAGMENT_SPREAD,\n        name: _name,\n        directives: directives(false),\n      };\n    } else {\n      idx = _idx;\n      const _typeCondition = typeCondition();\n      const _directives = directives(false);\n      const _selectionSet = selectionSet();\n      if (!_selectionSet) throw error('InlineFragment');\n      return {\n        kind: 'InlineFragment' as Kind.INLINE_FRAGMENT,\n        typeCondition: _typeCondition,\n        directives: _directives,\n        selectionSet: _selectionSet,\n      };\n    }\n  }\n}\n\nfunction selectionSet(): ast.SelectionSetNode | undefined {\n  let match: ast.SelectionNode | undefined;\n  ignored();\n  if (input.charCodeAt(idx) === 123 /*'{'*/) {\n    idx++;\n    ignored();\n    const selections: ast.SelectionNode[] = [];\n    while ((match = fragmentSpread() || field())) selections.push(match);\n    if (!selections.length || input.charCodeAt(idx++) !== 125 /*'}'*/) throw error('SelectionSet');\n    ignored();\n    return {\n      kind: 'SelectionSet' as Kind.SELECTION_SET,\n      selections,\n    };\n  }\n}\n\nfunction variableDefinitions(): ast.VariableDefinitionNode[] {\n  let match: string | undefined;\n  const vars: ast.VariableDefinitionNode[] = [];\n  ignored();\n  if (input.charCodeAt(idx) === 40 /*'('*/) {\n    idx++;\n    ignored();\n    while ((match = advance(variableRe))) {\n      ignored();\n      if (input.charCodeAt(idx++) !== 58 /*':'*/) throw error('VariableDefinition');\n      const _type = type();\n      let _defaultValue: ast.ValueNode | undefined;\n      if (input.charCodeAt(idx) === 61 /*'='*/) {\n        idx++;\n        ignored();\n        _defaultValue = value(true);\n        if (!_defaultValue) throw error('VariableDefinition');\n      }\n      ignored();\n      vars.push({\n        kind: 'VariableDefinition' as Kind.VARIABLE_DEFINITION,\n        variable: {\n          kind: 'Variable' as Kind.VARIABLE,\n          name: {\n            kind: 'Name' as Kind.NAME,\n            value: match.slice(1),\n          },\n        },\n        type: _type,\n        defaultValue: _defaultValue as ast.ConstValueNode,\n        directives: directives(true),\n      });\n    }\n    if (input.charCodeAt(idx++) !== 41 /*')'*/) throw error('VariableDefinition');\n    ignored();\n  }\n  return vars;\n}\n\nconst fragmentDefinitionRe = /fragment/y;\nfunction fragmentDefinition(): ast.FragmentDefinitionNode | undefined {\n  if (advance(fragmentDefinitionRe)) {\n    ignored();\n    const _name = name();\n    if (!_name) throw error('FragmentDefinition');\n    ignored();\n    const _typeCondition = typeCondition();\n    if (!_typeCondition) throw error('FragmentDefinition');\n    const _directives = directives(false);\n    const _selectionSet = selectionSet();\n    if (!_selectionSet) throw error('FragmentDefinition');\n    return {\n      kind: 'FragmentDefinition' as Kind.FRAGMENT_DEFINITION,\n      name: _name,\n      typeCondition: _typeCondition,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\n// NOTE(Safari10 Quirk): This *might* need to be wrapped in a group, but worked without it too\nconst operationDefinitionRe = /(?:query|mutation|subscription)/y;\n\nfunction operationDefinition(): ast.OperationDefinitionNode | undefined {\n  let _operation: string | undefined;\n  let _name: ast.NameNode | undefined;\n  let _variableDefinitions: ast.VariableDefinitionNode[] = [];\n  let _directives: ast.DirectiveNode[] = [];\n  if ((_operation = advance(operationDefinitionRe))) {\n    ignored();\n    _name = name();\n    _variableDefinitions = variableDefinitions();\n    _directives = directives(false);\n  }\n  const _selectionSet = selectionSet();\n  if (_selectionSet) {\n    return {\n      kind: 'OperationDefinition' as Kind.OPERATION_DEFINITION,\n      operation: (_operation || 'query') as OperationTypeNode,\n      name: _name,\n      variableDefinitions: _variableDefinitions,\n      directives: _directives,\n      selectionSet: _selectionSet,\n    };\n  }\n}\n\nfunction document(): ast.DocumentNode {\n  let match: ast.ExecutableDefinitionNode | void;\n  ignored();\n  const definitions: ast.ExecutableDefinitionNode[] = [];\n  while ((match = fragmentDefinition() || operationDefinition())) definitions.push(match);\n  return {\n    kind: 'Document' as Kind.DOCUMENT,\n    definitions,\n  };\n}\n\ntype ParseOptions = {\n  [option: string]: any;\n};\n\nexport function parse(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.DocumentNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return document();\n}\n\nexport function parseValue(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.ValueNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  ignored();\n  const _value = value(false);\n  if (!_value) throw error('ValueNode');\n  return _value;\n}\n\nexport function parseType(\n  string: string | Source,\n  _options?: ParseOptions | undefined\n): ast.TypeNode {\n  input = typeof string.body === 'string' ? string.body : string;\n  idx = 0;\n  return type();\n}\n","import { ASTNode } from './ast';\n\nexport const BREAK = {};\n\nexport function visit<N extends ASTNode>(root: N, visitor: ASTVisitor): N;\nexport function visit<R>(root: ASTNode, visitor: ASTReducer<R>): R;\n\nexport function visit(node: ASTNode, visitor: ASTVisitor | ASTReducer<any>) {\n  const ancestors: Array<ASTNode | ReadonlyArray<ASTNode>> = [];\n  const path: Array<string | number> = [];\n\n  function traverse(\n    node: ASTNode,\n    key?: string | number | undefined,\n    parent?: ASTNode | ReadonlyArray<ASTNode> | undefined\n  ) {\n    let hasEdited = false;\n\n    const enter =\n      (visitor[node.kind] && visitor[node.kind].enter) ||\n      visitor[node.kind] ||\n      (visitor as EnterLeaveVisitor<ASTNode>).enter;\n    const resultEnter = enter && enter.call(visitor, node, key, parent, path, ancestors);\n    if (resultEnter === false) {\n      return node;\n    } else if (resultEnter === null) {\n      return null;\n    } else if (resultEnter === BREAK) {\n      throw BREAK;\n    } else if (resultEnter && typeof resultEnter.kind === 'string') {\n      hasEdited = resultEnter !== node;\n      node = resultEnter;\n    }\n\n    if (parent) ancestors.push(parent);\n\n    let result: any;\n    const copy = { ...node };\n    for (const nodeKey in node) {\n      path.push(nodeKey);\n      let value = node[nodeKey];\n      if (Array.isArray(value)) {\n        const newValue: any[] = [];\n        for (let index = 0; index < value.length; index++) {\n          if (value[index] != null && typeof value[index].kind === 'string') {\n            ancestors.push(node);\n            path.push(index);\n            result = traverse(value[index], index, value);\n            path.pop();\n            ancestors.pop();\n            if (result == null) {\n              hasEdited = true;\n            } else {\n              hasEdited = hasEdited || result !== value[index];\n              newValue.push(result);\n            }\n          }\n        }\n        value = newValue;\n      } else if (value != null && typeof value.kind === 'string') {\n        result = traverse(value, nodeKey, node);\n        if (result !== undefined) {\n          hasEdited = hasEdited || value !== result;\n          value = result;\n        }\n      }\n\n      path.pop();\n      if (hasEdited) copy[nodeKey] = value;\n    }\n\n    if (parent) ancestors.pop();\n    const leave =\n      (visitor[node.kind] && visitor[node.kind].leave) ||\n      (visitor as EnterLeaveVisitor<ASTNode>).leave;\n    const resultLeave = leave && leave.call(visitor, node, key, parent, path, ancestors);\n    if (resultLeave === BREAK) {\n      throw BREAK;\n    } else if (resultLeave !== undefined) {\n      return resultLeave;\n    } else if (resultEnter !== undefined) {\n      return hasEdited ? copy : resultEnter;\n    } else {\n      return hasEdited ? copy : node;\n    }\n  }\n\n  try {\n    const result = traverse(node);\n    return result !== undefined && result !== false ? result : node;\n  } catch (error) {\n    if (error !== BREAK) throw error;\n    return node;\n  }\n}\n\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: ASTVisitFn<NodeT> | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\nexport type ASTVisitFn<Node extends ASTNode> = (\n  node: Node,\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => any;\n\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  key: string | number | undefined,\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  path: ReadonlyArray<string | number>,\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>\n) => R;\n\ntype ReducedField<T, R> = T extends null | undefined\n  ? T\n  : T extends ReadonlyArray<any>\n  ? ReadonlyArray<R>\n  : R;\n","import { ASTNode } from './ast';\n\nexport function printString(string: string) {\n  return JSON.stringify(string);\n}\n\nexport function printBlockString(string: string) {\n  return '\"\"\"\\n' + string.replace(/\"\"\"/g, '\\\\\"\"\"') + '\\n\"\"\"';\n}\n\nconst hasItems = <T>(array: ReadonlyArray<T> | undefined | null): array is ReadonlyArray<T> =>\n  !!(array && array.length);\n\nconst MAX_LINE_LENGTH = 80;\n\nconst nodes: {\n  [NodeT in ASTNode as NodeT['kind']]?: (node: NodeT) => string;\n} = {\n  OperationDefinition(node) {\n    if (\n      node.operation === 'query' &&\n      !node.name &&\n      !hasItems(node.variableDefinitions) &&\n      !hasItems(node.directives)\n    ) {\n      return nodes.SelectionSet!(node.selectionSet);\n    }\n    let out: string = node.operation;\n    if (node.name) out += ' ' + node.name.value;\n    if (hasItems(node.variableDefinitions)) {\n      if (!node.name) out += ' ';\n      out += '(' + node.variableDefinitions.map(nodes.VariableDefinition!).join(', ') + ')';\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + nodes.SelectionSet!(node.selectionSet);\n  },\n  VariableDefinition(node) {\n    let out = nodes.Variable!(node.variable) + ': ' + print(node.type);\n    if (node.defaultValue) out += ' = ' + print(node.defaultValue);\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  Field(node) {\n    let out = (node.alias ? node.alias.value + ': ' : '') + node.name.value;\n    if (hasItems(node.arguments)) {\n      const args = node.arguments.map(nodes.Argument!);\n      const argsLine = out + '(' + args.join(', ') + ')';\n      out =\n        argsLine.length > MAX_LINE_LENGTH\n          ? out + '(\\n  ' + args.join('\\n').replace(/\\n/g, '\\n  ') + '\\n)'\n          : argsLine;\n    }\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return node.selectionSet ? out + ' ' + nodes.SelectionSet!(node.selectionSet) : out;\n  },\n  StringValue(node) {\n    return node.block ? printBlockString(node.value) : printString(node.value);\n  },\n  BooleanValue(node) {\n    return '' + node.value;\n  },\n  NullValue(_node) {\n    return 'null';\n  },\n  IntValue(node) {\n    return node.value;\n  },\n  FloatValue(node) {\n    return node.value;\n  },\n  EnumValue(node) {\n    return node.value;\n  },\n  Name(node) {\n    return node.value;\n  },\n  Variable(node) {\n    return '$' + node.name.value;\n  },\n  ListValue(node) {\n    return '[' + node.values.map(print).join(', ') + ']';\n  },\n  ObjectValue(node) {\n    return '{' + node.fields.map(nodes.ObjectField!).join(', ') + '}';\n  },\n  ObjectField(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  Document(node) {\n    return hasItems(node.definitions) ? node.definitions.map(print).join('\\n\\n') : '';\n  },\n  SelectionSet(node) {\n    return '{\\n  ' + node.selections.map(print).join('\\n').replace(/\\n/g, '\\n  ') + '\\n}';\n  },\n  Argument(node) {\n    return node.name.value + ': ' + print(node.value);\n  },\n  FragmentSpread(node) {\n    let out = '...' + node.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out;\n  },\n  InlineFragment(node) {\n    let out = '...';\n    if (node.typeCondition) out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  FragmentDefinition(node) {\n    let out = 'fragment ' + node.name.value;\n    out += ' on ' + node.typeCondition.name.value;\n    if (hasItems(node.directives)) out += ' ' + node.directives.map(nodes.Directive!).join(' ');\n    return out + ' ' + print(node.selectionSet);\n  },\n  Directive(node) {\n    let out = '@' + node.name.value;\n    if (hasItems(node.arguments)) out += '(' + node.arguments.map(nodes.Argument!).join(', ') + ')';\n    return out;\n  },\n  NamedType(node) {\n    return node.name.value;\n  },\n  ListType(node) {\n    return '[' + print(node.type) + ']';\n  },\n  NonNullType(node) {\n    return print(node.type) + '!';\n  },\n};\n\nexport function print(node: ASTNode): string {\n  return nodes[node.kind] ? (nodes as any)[node.kind]!(node) : '';\n}\n","import { TypeNode, ValueNode } from './ast';\nimport { Maybe } from './types';\n\nexport function valueFromASTUntyped(\n  node: ValueNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  switch (node.kind) {\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'StringValue':\n    case 'EnumValue':\n    case 'BooleanValue':\n      return node.value;\n    case 'ListValue': {\n      const values: unknown[] = [];\n      for (const value of node.values) values.push(valueFromASTUntyped(value, variables));\n      return values;\n    }\n    case 'ObjectValue': {\n      const obj = Object.create(null);\n      for (const field of node.fields)\n        obj[field.name.value] = valueFromASTUntyped(field.value, variables);\n      return obj;\n    }\n    case 'Variable':\n      return variables && variables[node.name.value];\n  }\n}\n\nexport function valueFromTypeNode(\n  node: ValueNode,\n  type: TypeNode,\n  variables?: Maybe<Record<string, any>>\n): unknown {\n  if (node.kind === 'Variable') {\n    const variableName = node.name.value;\n    return variables ? valueFromTypeNode(variables[variableName], type, variables) : undefined;\n  } else if (type.kind === 'NonNullType') {\n    return node.kind !== 'NullValue' ? valueFromTypeNode(node, type, variables) : undefined;\n  } else if (node.kind === 'NullValue') {\n    return null;\n  } else if (type.kind === 'ListType') {\n    if (node.kind === 'ListValue') {\n      const values: unknown[] = [];\n      for (const value of node.values) {\n        const coerced = valueFromTypeNode(value, type.type, variables);\n        if (coerced === undefined) {\n          return undefined;\n        } else {\n          values.push(coerced);\n        }\n      }\n      return values;\n    }\n  } else if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Int':\n      case 'Float':\n      case 'String':\n      case 'Bool':\n        return type.name.value + 'Value' === node.kind\n          ? valueFromASTUntyped(node, variables)\n          : undefined;\n      default:\n        return valueFromASTUntyped(node, variables);\n    }\n  }\n}\n"],"names":["Kind","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","OperationTypeNode","QUERY","MUTATION","SUBSCRIPTION","GraphQLError","Error","constructor","message","nodes","source","positions","path","originalError","extensions","super","this","name","Array","isArray","let","_extensions","const","originalExtensions","toJSON","toString","toStringTag","Symbol","input","idx","error","kind","advance","pattern","lastIndex","test","slice","leadingRe","blockString","string","lines","split","out","commonIndent","firstNonEmptyLine","lastNonEmptyLine","length","i","replace","ignored","char","charCodeAt","nameRe","match","value","constRe","variableRe","intRe","floatPartRe","complexStringRe","blockStringRe","stringRe","constant","intPart","block","JSON","parse","list","values","push","object","fields","_name","_value","arguments_","args","directives","arguments","field","_alias","alias","selectionSet","type","_type","typeConditionRe","typeCondition","fragmentSpreadRe","fragmentSpread","_idx","_typeCondition","_directives","_selectionSet","selections","fragmentDefinitionRe","fragmentDefinition","operationDefinitionRe","operationDefinition","_operation","_variableDefinitions","variableDefinitions","vars","_defaultValue","variable","defaultValue","operation","_options","body","document","definitions","parseValue","parseType","BREAK","visit","node","visitor","ancestors","result","traverse","key","parent","hasEdited","enter","resultEnter","call","copy","nodeKey","newValue","index","pop","undefined","leave","resultLeave","printString","stringify","printBlockString","hasItems","array","OperationDefinition","SelectionSet","map","VariableDefinition","join","Directive","Variable","print","Field","Argument","argsLine","StringValue","BooleanValue","NullValue","_node","IntValue","FloatValue","EnumValue","Name","ListValue","ObjectValue","ObjectField","Document","FragmentSpread","InlineFragment","FragmentDefinition","NamedType","ListType","NonNullType","valueFromASTUntyped","variables","parseInt","parseFloat","obj","Object","create","i$1","list$1","valueFromTypeNode","coerced"],"mappings":"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"}